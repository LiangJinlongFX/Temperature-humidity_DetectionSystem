C51 COMPILER V9.56.0.0   MAIN                                                              01/02/2019 23:00:32 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files\MDK\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\STC8051_Detect
                    -ionSystem) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "sys.h"
   2          #include "uart.h"
   3          #include "DHT11.h"
   4          #include "lcd1602.h"
   5          #include "stc89c5xrc.h"
   6          
   7          u8 TimerISR_Count=0;
   8          u8 Global_LinkID;
   9          u8 Global_RevDataSize;
  10          DHT11Data_Type Global_DHT11Structure;
  11          sbit Switch = P2^3;
  12          void Response_Process(char Request_Type,DHT11Data_Type *pp);
  13          
  14          void main(void)
  15          {
  16   1        char Request_Type;
  17   1        u8 temp;
  18   1        unsigned long i=0;
  19   1        
  20   1        // 初始化LCD1602
  21   1        LCD1602_Init();
  22   1        // 初始化串口
  23   1        Uart_Init();
  24   1        // 初始化定时器0
  25   1        //Timer0_Init();
  26   1        // 串口中断设置为最高优先级
  27   1        PS = 1;
  28   1        // 开启全局中断
  29   1        EA = 1;
  30   1        
  31   1        // 显示启动信息
  32   1        LCD1602_DisplayString(5,0,"Welcome");
  33   1        LCD1602_DisplayString(3,1,"ChenJiandong");
  34   1        
  35   1        // AT指令设置ESP8266 TCP Server
  36   1        delay_ms(3000);
  37   1        Uart_SendString("ATE0\r\n");  //关闭指令回显
  38   1        delay_ms(100);
  39   1        Uart_SendString("AT+CIPMUX=1\r\n"); //使能TCP多连接
  40   1        delay_ms(100);
  41   1        Uart_SendString("AT+CIPSERVER=1,8000\r\n"); //建立TCP服务器,监听端口8000
  42   1        delay_ms(100);
  43   1        Uart_SendString("AT+CIPSTO=600\r\n"); //建立超时时间
  44   1        delay_ms(100);
  45   1        
  46   1        // 显示温湿度显示界面
  47   1        LCD1602_Clear();
  48   1        LCD1602_DisplayString(2,0,"TEMP:  .  ^C");
  49   1        LCD1602_DisplayString(3,1,"RH :  .  %");
  50   1        while(1)
  51   1        {
  52   2          if(Global_UartRev_Flag)
  53   2          {
  54   3            Global_UartRev_Flag = 0;  //复位接收标记
C51 COMPILER V9.56.0.0   MAIN                                                              01/02/2019 23:00:32 PAGE 2   

  55   3            Global_LinkID = Global_UartBuffer[7] - '0'; //获取请求的客户端ID
  56   3            Request_Type = Global_UartBuffer[11];   //获取请求类型
  57   3            Response_Process(Request_Type,&Global_DHT11Structure);
  58   3            Global_UartRev_Count = 0; //清除缓冲计数
  59   3            ES = 1;
  60   3          }
  61   2          i++;
  62   2          if(i>50000)
  63   2          {
  64   3            i=0;
  65   3            temp = DHT11_ReadData(&Global_DHT11Structure);
  66   3            if(!temp)
  67   3            {
  68   4              Switch = ~Switch;
  69   4              LCD1602_DisplayData(&Global_DHT11Structure);
  70   4            }
  71   3          }
  72   2        }
  73   1      }
  74          
  75          void Response_Process(char Request_Type,DHT11Data_Type *pp)
  76          {
  77   1        char payload[10];
  78   1        
  79   1        if(Request_Type == 1)
  80   1        {
  81   2          payload[0] = 0x88;  //响应数据类型
  82   2          payload[1] = pp->T_H; //湿度整数位
  83   2          payload[2] = pp->T_L; //湿度小数位
  84   2          payload[3] = pp->RH_H;    //温度整数位
  85   2          payload[4] = pp->RH_L;    //温度小数位
  86   2          payload[5] = 23;  //温湿度校验位
  87   2          payload[6] = 0x00;  //填充字符'\0'
  88   2          Uart_SendString("AT+CIPSEND=");
  89   2          Uart_SendChar(Global_LinkID+'0');
  90   2          Uart_SendString(",6\r\n");
  91   2          delay_ms(50);
  92   2          Uart_SendString(payload);
  93   2        }
  94   1        else if(Request_Type == 2)
  95   1        {
  96   2          Switch = ~Switch;
  97   2          payload[0] = 0x89;  //响应数据类型
  98   2          if(Switch)
  99   2            payload[1] = 2;
 100   2          else
 101   2            payload[1] = 1;
 102   2          payload[2] = 0x00;  //填充字符'\0'
 103   2          Uart_SendString("AT+CIPSEND=");
 104   2          Uart_SendChar('0'+Global_LinkID);
 105   2          Uart_SendString(",2\r\n");
 106   2          delay_ms(50);
 107   2          Uart_SendString(payload);
 108   2        }
 109   1      }
 110          
 111          
 112          /**
 113           * 定时器0中断服务函数
 114           * @param   
 115           * @return 
 116           * @brief 
C51 COMPILER V9.56.0.0   MAIN                                                              01/02/2019 23:00:32 PAGE 3   

 117           **/
 118          void Timer0_ISR_Handler() interrupt 1
 119          {
 120   1        ET0 = 0;
 121   1        TL0 = 0x00;                     //reload timer0 low byte
 122   1        TH0 = 0xB8;                     //reload timer0 high byte
 123   1        if(++TimerISR_Count >= 200)
 124   1        {
 125   2          Switch = ~Switch;
 126   2          TimerISR_Count = 0;
 127   2        }
 128   1        ET0 =1;
 129   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    481    ----
   CONSTANT SIZE    =    126    ----
   XDATA SIZE       =      8      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
